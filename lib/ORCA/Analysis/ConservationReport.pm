=head1 NAME

ORCA::Analysis::ConservationReport - Object to hold the results
of a conservation analysis (currently only generated by
ORCA::Analysis::Run::AlignCons).

=head1 SYNOPSIS

    use ORCA::Analysis::ConservationReport;

=head1 DESCRIPTION

=head1 AUTHOR

  David Arenillas
  Wasserman Lab
  Centre for Molecular Medicine and Therapeutics
  University of British Columbia

  E-mail: dave@cmmt.ubc.ca

=head1 METHODS

=cut

package ORCA::Analysis::ConservationReport;

use strict;

use Carp;
use Bio::SeqFeature::FeaturePair;

=head2

 Title    : new
 Usage    : my $report = ORCA::Analysis::ConservationReport->new(
				-report_type		=> 'c'),
				-conserved_regions	=> $regions,
				-filtered_features	=> $features,
				-alignment		=> $align);
 Function : Create a new ORCA::Analysis::ConservationReport object.
 Returns  : A ORCA::Analysis::ConservationReport object.
 Args     : report_type which must be either 'c' for a conserved regions
            report or 'p' for a conservation profile report. If report type
	    is 'c' a conserved_regions parameter must be specified whose
	    value is a reference to a list of
	    ORCA::Analysis::ConservedRegion objects. For report
	    type of 'p' a conservation_profile parameter must be passed
	    whose value should be a reference to a list of points
	    containing position and score. The alignment which was analyzed
	    to create the report must also be provided whose value is a
	    Bio::SimpleAlign object.

=cut

sub new
{
    my ($class, %args) = @_;
    my $self = bless {
			-parameters		=> {},
			-report_type		=> undef,
			-alignment		=> undef,
			-filtered_features	=> undef,
			-conserved_regions	=> undef,
			-conservation_profile	=> undef,
			%args
		    }, ref $class || $class;

    if (!defined $self->{-report_type}) {
	carp "must provide a report_type\n";
	return undef;
    }

    $self->{-report_type} = lc $self->{-report_type};

    if ($self->{-report_type} ne 'c' && $self->{-report_type} ne 'p') {
	carp "report_type must be either 'c' or 'p'\n";
	return undef;
    }

    if ($self->{-report_type} eq 'c') {
	if (!defined($self->{-conserved_regions})
	    	|| ref $self->{-conserved_regions} ne "ARRAY")
	{
	    carp "conserved_regions argument missing or wrong object type\n";
	    return undef;
	}
    } elsif ($self->{-report_type} eq 'p') {
	if (!defined($self->{-conservation_profile})
		|| ref $self->{-conservation_profile} ne "ARRAY")
	{
	    carp "conservation_profile argument missing or wrong object type\n";
	    return undef;
	}
    }

    if (!defined($self->{-alignment})
		|| !$self->{-alignment}->isa("Bio::SimpleAlign"))
    {
	carp "alignment argument missing or is not a Bio::SimpleAlign object\n";
	return undef;
    }

    return $self;
}

=head2

 Title    : conserved_regions_as_gff
 Usage    : my $gff = $report->conserved_regions_as_gff();
 Function : Return the conserved regions in GFF formatted ouput.
 Returns  : Conserved regions formatted as GFF.
 Args     : None.

=cut

#
# Adapted from Boris Lenhard's CONSNP::ConservationProfile module
#
sub conserved_regions_as_gff
{
    my ($self,  %args) = @_;

    my $features = $self->conserved_regions_as_features;
    my $output = "";
    foreach my $f (@$features) {
        $output .= $f->gff_string . "\n";
    }

    return $output;
}

=head2

 Title    : conserved_regions_as_features
 Usage    : my $features = $report->conserved_regions_as_features();
 Function : Return the conserved regions as features.
 Returns  : A reference to a list of Bio::SeqFeature::Generic objects.
 Args     : None.

=cut

sub conserved_regions_as_features
{
    my ($self,  %args) = @_;

    my $regions = $self->conserved_regions;
    return undef if !defined $regions;

    #
    # Originally used the primary_id, but this is often not set to
    # anything and therefore just returns a stringified memory location
    # which is not very pretty.
    #
    my $seq_id1 = $self->alignment->get_seq_by_pos(1)->id;
    my $seq_id2 = $self->alignment->get_seq_by_pos(2)->id;

    my @features;
    my $counter = 1;
    foreach my $region (@$regions) {
	my $primary = sprintf("${seq_id1}:CR%04d", $counter);
	my $feature = Bio::SeqFeature::Generic->new(
			-primary	=> $primary,
			-seq_id		=> $seq_id1,
			-source_tag	=> "align_cons",
			-start		=> $region->seq1_start,
			-end		=> $region->seq1_end,
			-score		=> $region->score,
			-tag		=> {
				    seq2_id	=> $seq_id2,
				    seq2_start	=> $region->seq2_start,
				    seq2_end	=> $region->seq2_end,
				    align_start	=> $region->align_start,
				    align_end	=> $region->align_end});

	push @features, $feature;

	$counter++;
    }

    return @features ? \@features : undef;
}

=head2

 Title    : conserved_regions_as_feature_pairs
 Usage    : my $fp = $report->conserved_regions_as_feature_pairs();
 Function : Return the conserved regions as feature pairs.
 Returns  : A reference to a list of Bio::SeqFeature::FeaturePair objects.
 Args     : None.

=cut

sub conserved_regions_as_feature_pairs
{
    my ($self,  %args) = @_;

    my $regions = $self->conserved_regions;
    return undef if !defined $regions;

    #
    # Originally used the primary_id, but this is often not set to
    # anything and therefore just returns a stringified memory location
    # which is not very pretty.
    #
    my $seq_id1 = $self->alignment->get_seq_by_pos(1)->id;
    my $seq_id2 = $self->alignment->get_seq_by_pos(2)->id;

    my @feature_pairs;
    my $counter = 1;
    foreach my $region (@$regions) {
	my $primary1 = sprintf("${seq_id1}:CR%04d", $counter);
	my $primary2 = sprintf("${seq_id2}:CR%04d", $counter);

	my $feature1 = Bio::SeqFeature::Generic->new(
			-primary	=> $primary1,
			-seq_id		=> $seq_id1,
			-source_tag	=> "align_cons",
			-start		=> $region->seq1_start,
			-end		=> $region->seq1_end,
			-score		=> $region->score,
			-tag		=> {
				    align_start	=> $region->align_start,
				    align_end	=> $region->align_end});

	my $feature2 = Bio::SeqFeature::Generic->new(
			-primary	=> $primary2,
			-seq_id		=> $seq_id2,
			-source_tag	=> "align_cons",
			-start		=> $region->seq2_start,
			-end		=> $region->seq2_end,
			-score		=> $region->score,
			-tag		=> {
				    align_start	=> $region->align_start,
				    align_end	=> $region->align_end});

	push @feature_pairs, Bio::SeqFeature::FeaturePair->new(
	    				-feature1	=> $feature1,
					-feature2	=> $feature2);

	$counter++;
    }

    return @feature_pairs ? \@feature_pairs : undef
}


################################################################################
#
# Getter/setter methods.
#
################################################################################

=head2

 Title    : report_type
 Usage    : my $report_type = $report->report_type();
 Function : Return the type of the report.
 Returns  : A 'c' indicating a conserved regions report or a 'p' indicating
 	    a conservation profile report.
 Args     : None.

=cut

sub report_type
{
    $_[0]->{-report_type};
}

=head2

 Title    : alignment
 Usage    : my $alignment = $report->alignment();
 Function : Return the alignment used to generate the report.
 Returns  : A Bio::SimpleAlign object.
 Args     : None.

=cut

sub alignment
{
    $_[0]->{-alignment};
}

=head2

 Title    : filtered_features
 Usage    : my $filtered_features = $report->filtered_features();
 Function : Return the features which were optionally used to filter out
 	    of conserved regions.
 Returns  : A list of Bio::SeqFeatureI objects.
 Args     : None.

=cut

sub filtered_features
{
    $_[0]->{-filtered_features};
}

=head2

 Title    : conserved_regions
 Usage    : my $regions = $report->conserved_regions();
 Function : Return the conserved regions.
 Returns  : A reference to a list of
            ORCA::Analysis::ConservedRegion objects.
 Args     : None.

=cut

sub conserved_regions
{
    my ($self) = @_;

    if ($self->report_type ne 'c') {
	carp "This report type does not support conserved regions\n";
	return undef;
    }

    return $self->{-conserved_regions};
}

=head2

 Title    : conservation_profile
 Usage    : my $profile = $report->conservation_profile();
 Function : Return the conservation profile.
 Returns  : A reference to a list of points containing positions and scores.
 Args     : None.

=cut

sub conservation_profile
{
    my ($self) = @_;

    if ($self->report_type ne 'p') {
	carp "This report type does not support a conservation profile\n";
	return undef;
    }

    return $self->{-conservation_profile};
}

=head2

 Title    : param
 Usage    : my $value = $report->param($param);
 Function : Get/Set the value of report parameter or return a list of
            defined parameter names.
 Returns  : If a parameter name is provided, the value of that parameter,
            otherwise a list of all the defined parameter names.
 Args     : None.

=cut

sub param
{
    my ($self, $param, $value) = @_;

    if (!defined $param) {
	return keys %{$self->{-parameters}};
    } elsif (defined $value) {
	$self->{-parameters}->{-$param} = $value;
    }

    return $self->{-parameters}->{-$param};
}

1;
